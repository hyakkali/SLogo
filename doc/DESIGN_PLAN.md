### API Example Code

* Suppose the following sequence is executed:

> The user types 'fd 50' in the command window, and sees the turtle move in the display window leaving a trail, and the command is added to the environment's history.

In doing so, several calls will be made in both the internal and external APIs of View and Model. Here is a well-commented piece of example code (without specific implementation) that shows how the API flow is structured:

```java
	/**
	 * Executed by View's internal API, will get the user input text from the console
	 * @return the dialog currently in the console. Done within the UserCommands class.
	 */
	protected String consoleInput();

	/**
	 * Add the command to the environment's history. This is done in the View's internal API.
 * The command is added to an instance variable representing the most recently
 * executed commands. Done within the UserCommands class.
	 */
	protected void addToHistory();

	/** 
	 * The Model interacts with the View here, getting the String that was input to the console.
	 * This method is contained in Model's external API. Done within the Interpreter class.
	 * @return the dialog that was input into the console
	 */
	public String getInput();

	/**
	 * Inside of the Model (internal API), the interpreter parses the input that it got from the user
	 * and returns a Command object. Done in the Interpreter class.
	 * @param input what the user typed into the console
	 * @return a Command object that represents what the user input
	 */
	public Command parse(String input);

	/**
	 * Inside of the Model (internal API), uses the command parsed above to update all properties of the turtle.
	 * However, since the turtle is contained in the view, this just returns a Properties object representing new properties of the  
	 * turtle. Done in the Interpreter class.
	 * @param command the command generated by parsing
	 * @return a Properties object representing the updated properties of the turtle
	 */
	protected Properties generateTurtleProperties(Command command);

	/**
	 * Inside of View's external API, updates the position of the Turtle. It must get this information from the Properties object
	 * generated by the above method. Done within the Turtle class.
	 * @param newProperties the new properties generated by the above method.
	 */
	public void updateTurtle(Properties newProperties);

	/**
	 * Finally, the turtle is drawn within the View's internal API. This includes drawing the line. The method updates a turtle object 
	 * that the GUI class holds.
	 */
	protected void updateTurtleView();
```

View - User Interface

User wants to choose a different image for the turtle 

```java
/**
* Executed by View’s internal API, will get new image that user just uploaded to the program
*/
private File getImage();

/**
* Executed by View’s internal API, will add uploaded image file to the drop-down menu that allows users to choose an image for the turtle
*/
private void addImage(File image);

/**
* Executed by View’s internal API, will set turtle to the new image uploaded and chosen by user
*/
private void setImage(File image);
```

User wants to choose a different language for the commands 

```java
	/**
	* Executed in View’s external API, sets properties file that the Commands class uses 
	*/
	public void setLanguagePropertiesFile(String language);
```

User types fd 50 when the turtle is near the edge and it appears on the other side

```java
	/**
	 * Executed by View's internal API, will get the user input text from the console
	 * @return the dialog currently in the console. Done within the UserCommands class.
	 */
	protected String consoleInput();

	/**
	 * Add the command to the environment's history. This is done in the View's internal API.
 * The command is added to an instance variable representing the most recently
 * executed commands. Done within the UserCommands class.
	 */
	protected void addToHistory();

	/** 
	 * The Model interacts with the View here, getting the String that was input to the console.
	 * This method is contained in Model's external API. Done within the Interpreter class.
	 * @return the dialog that was input into the console
	 */
	public String getInput();

	/**
	 * Inside of the Model (internal API), the interpreter parses the input that it got from the user
	 * and returns a Command object. Done in the Interpreter class.
	 * @param input what the user typed into the console
	 * @return a Command object that represents what the user input
	 */
	public Command parse(String input);

	/**
	 *inside the external view API, the view section is asked for its coordinates 
	* and returns the current size of the frame in which the turtle occupies
*  and the command is generated to move the turtle in a toroidal fashion
	*/
	public int getWindowSize();


	/**
* Inside of the Model (internal API), uses the command parsed above to update all properties of the turtle.
 * However, since the turtle is contained in the view, this just returns a Properties object 
 * representing new properties of the  
	 * turtle. Done in the Interpreter class.
	 * @param command the command generated by parsing
	 * @return a Properties object representing the updated properties of the turtle
	 */
	protected Properties generateTurtleProperties(Command command);

	/**
	 * Inside of View's external API, updates the position of the Turtle. It must get this information from the Properties object
	 * generated by the above method. Done within the Turtle class.
	 * @param newProperties the new properties generated by the above method.
	 */
	public void updateTurtle(Properties newProperties);
```
User wants to redo a certain command

```java
	/**
	 * Executed by View's internal API, when a key is pressed it will assess the value of the 
	 * key and call correct methods as defined by the architecture (in this case the key is up arrow 
	 * and cycleHistory() is called
	 */
	private void handelKeyPressed();

/**
	 * Executed by View's internal API, when pressed the UI will cycle through a list
	 * of the history of string commands entered as created in addHistory, clear the textbox and 
	 * add the command from the list to the form 
	 */
	private void cycleHistory();
```


	


### Intro

In implementing this project, our team will create a functional, high level and user-friendly programming language designed for children to experiment with programming. The program will allow the user to update the color and position of a turtle sprite by typing single to multiple line codes referenced in the library of commands we write for the project. The project will be split up into several components-- the UI which is responsible for handling user input to the text console, displaying the information, and initializing the program, the backend which will take input from the UI and convert the slogo commands to java methods to be called on the turtle object in order to update it, hold data, and send it to the UI, and a controller which will manage the interactions between these two. To maintain efficient programming and decrease the work necessary to implement/ extend our design, we will ensure that the interactions between the UI and backend are as limited as possible-- our plan currently allows for the sharing of turtle information, sending and receiving text from the console, and getting basic information about the size of the form the turtle occupies. These interactions are to be rigid and remove the possibility of data being misused. We are designing with the intent of adding new commands and features, and we intend to do this by making modular classes and methods and by using the concept of properties tables. In general the backend will be most open to allow more complicated commands.

___
### Design Overview

This project makes use of 4 primary APIs -- Visualizer internal, Visualizer external, Backend internal, and Backend external with the following responsibilities: 
* Visualizer internal
	* Update the display based on the location and past movement of the turtle
    * input from the console as users type commands
    * Initialize the UI
* Visualizer external
    * Get/ set the position and orientation of the form and the turtle as the backend sends this    	 * information
    * Send information about the size of the drawing form to the backend
* Backend internal 
	* Translate parsed text into a list of commands to be executed on the turtle 
    * Execute these commands 
    * Maintain the library of slogo commands to be called
* Backend external 
    * Receive input from the parser/ front end side
    * Send the new information about turtle to the front end after each command
    * Generate a command list to send to the front end 

Within these APIs and the two ends of the project will be a variety of classes which will interact with each other as follows:

![picture](images/CRC.JPG)

------


### User Interface 

The user interface will consist of a large window that displays the turtle and lines that reflect the turtle’s movement. On the right side, there will be a pane that includes a list of past and possible commands that the user can give to the turtle, a list of current environment variables, a drop-down menu allowing the user to choose the color of the turtle, and a button that allows the user to upload an image file to replace the default turtle image. There will also be a dropdown menu to allow the user to choose the background color for the turtle screen, another menu to choose the pen color, and another to choose the language of the commands. On the bottom, there will be a large text field where the user will input commands for the program to run and right next to the text field will be a button that will run the inputted commands when it is pushed. 

![picture](images/UI.JPG)


### Team Responsibilities 

Hemanth - On the View team, will primarily be responsible for creating the user interface

Conrad - On the View team, I will be working with Hemanth to create the user interface and add features pertaining to displaying previous commands and the potential list as well as how to use the language, and I will be working with the backend team to facilitate the exchange of information between the two halves of the project.

Alexi - 

Dylan - 
